# Exercises 1.05

```scheme
(define (p) (p))
(define (test x y) (if (= x 0) 0 y))

(display (test 0 (p)))
```

## 应用序

> 先求值再应用

若解释器的求值规则是应用序的，那么在执行`(test 0 (p))`过程时，会先对参数进行求值，而参数`(p)`过程是递归自调用，此时会造成无限循环。

**由于解释器有尾递归优化机制，因此会无限消耗内存而不会导致堆栈溢出。**

## 正则序

> 先展开再求值，亦叫惰性求值

若解释器的求值规则是正则序的，那么在执行`(test 0 (p))`过程时，会先展开代入：

```scheme
(test 0 (p))

(if (= 0 0) 0 (p))
```

此时由于判断条件通过，结果返回`0`，于是`(p)`过程的求值被忽略。
